
//! This file has been generated by rustypy and contains bindings for Python.
//! rustypy version: alpha
//! Python implementation build version: cpython-35

// IMPORTANT: This file will be replaced on new rustypy calls.
// Don't write on it directly, rather call functions from an other file.

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_imports,
    unused_variables)]

use libc::{c_long, c_double};
use cpython::{Python, ToPyObject, FromPyObject, ObjectProtocol,
              PythonObjectWithCheckedDowncast, PyObject, PyModule, PyErr,
              PyDict, NoArgs};
use std::collections::HashMap;

fn handle_import_error(err: PyErr) {
    println!("failed to load Python module, reason:
             {}", err.pvalue.unwrap());
}

/// Binds for Python module `nested_types`
pub struct GgnENC {
    module: PyModule
}

impl GgnENC {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<GgnENC> {
        let module = py.import("test_package.basics.nested_types");
        match module {
            Ok(m) => Some(
                GgnENC {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn list1(&self, py: Python,
        ls_arg: Vec<(c_double, bool)>
    ) -> Vec<String> {

        let func = self.module.get(py, "list1").unwrap();
        let ls_arg = ls_arg.to_py_object(py);
        let result = func.call(py, (ls_arg, ), None).unwrap();
        let mut hyWNuP = vec![];
        for e in result.iter(py).unwrap() {
            hyWNuP.push(e.unwrap().extract::<String>(py).unwrap());
        };

        return hyWNuP

    }

    pub fn cmpd_tuple(&self, py: Python,
        tup_arg1: (c_long, (c_double, bool))
    ) -> (c_long, (String, bool), c_double) {

        let func = self.module.get(py, "cmpd_tuple").unwrap();
        let tup_arg1 = tup_arg1.to_py_object(py);
        let result = func.call(py, (tup_arg1, ), None).unwrap();
            let HJcoWe = result.get_item(py,0).unwrap().extract::<c_long>(py).unwrap();
            let lyjuGI = result.get_item(py, 1).unwrap();
                let fPUpbQ = lyjuGI.get_item(py,0).unwrap().extract::<String>(py).unwrap();
                let XDNdki = lyjuGI.get_item(py,1).unwrap().extract::<bool>(py).unwrap();
            let sAsBLV = result.get_item(py,2).unwrap().extract::<c_double>(py).unwrap();

        return (HJcoWe, (fPUpbQ, XDNdki), sAsBLV)

    }

    pub fn cmpd_list(&self, py: Python,
        arg1: Vec<(c_long, bool)>,
        arg2: Vec<c_long>
    ) -> Vec<(Vec<c_long>, c_double)> {

        let func = self.module.get(py, "cmpd_list").unwrap();
        let arg1 = arg1.to_py_object(py);
        let arg2 = arg2.to_py_object(py);
        let result = func.call(py, (arg1, arg2, ), None).unwrap();
        let mut wNUsZt = vec![];
        for e in result.iter(py).unwrap() {
            let uTwPwR = e.unwrap();
                let SqacCq = uTwPwR.get_item(py, 0).unwrap();
                let mut twqqEf = vec![];
                for e in SqacCq.iter(py).unwrap() {
                    twqqEf.push(e.unwrap().extract::<c_long>(py).unwrap());
                };
                let BNGyZZ = uTwPwR.get_item(py,1).unwrap().extract::<c_double>(py).unwrap();
            let uTwPwR = (twqqEf, BNGyZZ);
            wNUsZt.push(uTwPwR);
        };

        return wNUsZt

    }

    pub fn cmpd_list_and_tuple(&self, py: Python,
        ls_arg: Vec<((String, bool), PyObject)>
    ) -> Vec<(c_long, bool)> {

        let func = self.module.get(py, "cmpd_list_and_tuple").unwrap();
        let ls_arg = ls_arg.to_py_object(py);
        let result = func.call(py, (ls_arg, ), None).unwrap();
        let mut ftBdyw = vec![];
        for e in result.iter(py).unwrap() {
            let RjTCIJ = e.unwrap();
                let GLNuzO = RjTCIJ.get_item(py,0).unwrap().extract::<c_long>(py).unwrap();
                let JCZnvv = RjTCIJ.get_item(py,1).unwrap().extract::<bool>(py).unwrap();
            let RjTCIJ = (GLNuzO, JCZnvv);
            ftBdyw.push(RjTCIJ);
        };

        return ftBdyw

    }

    pub fn dict1(&self, py: Python,
        dict_arg: HashMap<String, c_long>
    ) -> HashMap<String, c_long> {

        let func = self.module.get(py, "dict1").unwrap();
        let dict_arg = dict_arg.to_py_object(py);
        let result = func.call(py, (dict_arg, ), None).unwrap();
        let mut NwtWoV = HashMap::new();
        let NwtWoV_d: PyDict = PyDict::downcast_from(py, result).unwrap();
        for (key, value) in NwtWoV_d.items(py) {
            let dict_key = key.extract::<String>(py).unwrap();
            let dict_value = value.extract::<c_long>(py).unwrap();
            NwtWoV.insert(dict_key, dict_value);
        };

        return NwtWoV

    }

    pub fn cmpd_list_and_dict(&self, py: Python,

    ) -> Vec<HashMap<c_long, (String, bool)>> {

        let func = self.module.get(py, "cmpd_list_and_dict").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let mut sRTrED = vec![];
        for e in result.iter(py).unwrap() {
            let DKsxTG = e.unwrap();
            let mut qnvCEj = HashMap::new();
            let qnvCEj_d: PyDict = PyDict::downcast_from(py, DKsxTG).unwrap();
            for (key, value) in qnvCEj_d.items(py) {
                let dict_key = key.extract::<c_long>(py).unwrap();
                let EcLrRK = value;
                    let FixHqd = EcLrRK.get_item(py,0).unwrap().extract::<String>(py).unwrap();
                    let iMJnIV = EcLrRK.get_item(py,1).unwrap().extract::<bool>(py).unwrap();
                let dict_value = (FixHqd, iMJnIV);
                qnvCEj.insert(dict_key, dict_value);
            };
            sRTrED.push(qnvCEj);
        };

        return sRTrED

    }

    pub fn cmpd_dict(&self, py: Python,

    ) -> HashMap<String, HashMap<c_long, (String, bool)>> {

        let func = self.module.get(py, "cmpd_dict").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let mut obwSVs = HashMap::new();
        let obwSVs_d: PyDict = PyDict::downcast_from(py, result).unwrap();
        for (key, value) in obwSVs_d.items(py) {
            let dict_key = key.extract::<String>(py).unwrap();
            let mut ylxRgr = HashMap::new();
            let ylxRgr_d: PyDict = PyDict::downcast_from(py, value).unwrap();
            for (key, value) in ylxRgr_d.items(py) {
                let dict_key = key.extract::<c_long>(py).unwrap();
                let JDcuqk = value;
                    let McCuTZ = JDcuqk.get_item(py,0).unwrap().extract::<String>(py).unwrap();
                    let qyfhYT = JDcuqk.get_item(py,1).unwrap().extract::<bool>(py).unwrap();
                let dict_value = (McCuTZ, qyfhYT);
                ylxRgr.insert(dict_key, dict_value);
            };
            let dict_value = ylxRgr;
            obwSVs.insert(dict_key, dict_value);
        };

        return obwSVs

    }

    pub fn generic2(&self, py: Python,
        g_arg: Vec<PyObject>
    ) -> Vec<PyObject> {

        let func = self.module.get(py, "generic2").unwrap();
        let g_arg = g_arg.to_py_object(py);
        let result = func.call(py, (g_arg, ), None).unwrap();
        let mut HQOhbC = vec![];
        for e in result.iter(py).unwrap() {
            HQOhbC.push(e.unwrap().extract::<PyObject>(py).unwrap());
        };

        return HQOhbC

    }

    pub fn dict2(&self, py: Python,
        dict_arg: HashMap<String, (String, bool)>
    ) -> HashMap<String, (String, bool)> {

        let func = self.module.get(py, "dict2").unwrap();
        let dict_arg = dict_arg.to_py_object(py);
        let result = func.call(py, (dict_arg, ), None).unwrap();
        let mut uIJMDs = HashMap::new();
        let uIJMDs_d: PyDict = PyDict::downcast_from(py, result).unwrap();
        for (key, value) in uIJMDs_d.items(py) {
            let dict_key = key.extract::<String>(py).unwrap();
            let BtISol = value;
                let qjCjDs = BtISol.get_item(py,0).unwrap().extract::<String>(py).unwrap();
                let MXmJQv = BtISol.get_item(py,1).unwrap().extract::<bool>(py).unwrap();
            let dict_value = (qjCjDs, MXmJQv);
            uIJMDs.insert(dict_key, dict_value);
        };

        return uIJMDs

    }

    pub fn generic1(&self, py: Python,
        g_arg: PyObject
    ) -> PyObject {

        let func = self.module.get(py, "generic1").unwrap();
        let g_arg = g_arg.to_py_object(py);
        let result = func.call(py, (g_arg, ), None).unwrap();
        let mVMgbt = result.extract::<PyObject>(py).unwrap();

        return mVMgbt

    }

    pub fn cmpd_dict_and_ls(&self, py: Python,

    ) -> HashMap<c_long, Vec<c_double>> {

        let func = self.module.get(py, "cmpd_dict_and_ls").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let mut XKacDh = HashMap::new();
        let XKacDh_d: PyDict = PyDict::downcast_from(py, result).unwrap();
        for (key, value) in XKacDh_d.items(py) {
            let dict_key = key.extract::<c_long>(py).unwrap();
            let mut HLAqTE = vec![];
            for e in value.iter(py).unwrap() {
                HLAqTE.push(e.unwrap().extract::<c_double>(py).unwrap());
            };
            let dict_value = HLAqTE;
            XKacDh.insert(dict_key, dict_value);
        };

        return XKacDh

    }

}

/// Binds for Python module `primitives`
pub struct XKTQmi {
    module: PyModule
}

impl XKTQmi {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<XKTQmi> {
        let module = py.import("test_package.basics.primitives");
        match module {
            Ok(m) => Some(
                XKTQmi {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn rust_bind_str_func(&self, py: Python,
        str_arg: String
    ) -> String {

        let func = self.module.get(py, "rust_bind_str_func").unwrap();
        let str_arg = str_arg.to_py_object(py);
        let result = func.call(py, (str_arg, ), None).unwrap();
        let WurXws = result.extract::<String>(py).unwrap();

        return WurXws

    }

    pub fn rust_bind_tuple1(&self, py: Python,
        tup_arg: (String, c_long)
    ) -> (String, c_long) {

        let func = self.module.get(py, "rust_bind_tuple1").unwrap();
        let tup_arg = tup_arg.to_py_object(py);
        let result = func.call(py, (tup_arg, ), None).unwrap();
            let pgZkKF = result.get_item(py,0).unwrap().extract::<String>(py).unwrap();
            let TIPRME = result.get_item(py,1).unwrap().extract::<c_long>(py).unwrap();

        return (pgZkKF, TIPRME)

    }

    pub fn rust_bind_tuple2(&self, py: Python,
        tup_arg: (String, bool)
    ) -> (String, bool) {

        let func = self.module.get(py, "rust_bind_tuple2").unwrap();
        let tup_arg = tup_arg.to_py_object(py);
        let result = func.call(py, (tup_arg, ), None).unwrap();
            let qkSBvc = result.get_item(py,0).unwrap().extract::<String>(py).unwrap();
            let aLywnc = result.get_item(py,1).unwrap().extract::<bool>(py).unwrap();

        return (qkSBvc, aLywnc)

    }

    pub fn rust_bind_int_func(&self, py: Python,
        int_arg: c_long
    ) -> c_long {

        let func = self.module.get(py, "rust_bind_int_func").unwrap();
        let int_arg = int_arg.to_py_object(py);
        let result = func.call(py, (int_arg, ), None).unwrap();
        let ZLYqYp = result.extract::<c_long>(py).unwrap();

        return ZLYqYp

    }

    pub fn rust_bind_float_func(&self, py: Python,
        float_arg: c_double
    ) -> c_double {

        let func = self.module.get(py, "rust_bind_float_func").unwrap();
        let float_arg = float_arg.to_py_object(py);
        let result = func.call(py, (float_arg, ), None).unwrap();
        let galXMd = result.extract::<c_double>(py).unwrap();

        return galXMd

    }

    pub fn rust_bind_bool_func(&self, py: Python,
        bool_arg: bool
    ) -> bool {

        let func = self.module.get(py, "rust_bind_bool_func").unwrap();
        let bool_arg = bool_arg.to_py_object(py);
        let result = func.call(py, (bool_arg, ), None).unwrap();
        let IHJEHj = result.extract::<bool>(py).unwrap();

        return IHJEHj

    }

    pub fn rust_bind_tuple3(&self, py: Python,
        tup_arg1: c_double,
        tup_arg2: bool
    ) -> (c_double, bool) {

        let func = self.module.get(py, "rust_bind_tuple3").unwrap();
        let tup_arg1 = tup_arg1.to_py_object(py);
        let tup_arg2 = tup_arg2.to_py_object(py);
        let result = func.call(py, (tup_arg1, tup_arg2, ), None).unwrap();
            let gGguqJ = result.get_item(py,0).unwrap().extract::<c_double>(py).unwrap();
            let kYkblg = result.get_item(py,1).unwrap().extract::<bool>(py).unwrap();

        return (gGguqJ, kYkblg)

    }

}

/// Struct for folder `basics`
pub struct xgHOWu {
    pub nested_types: GgnENC,
    pub primitives: XKTQmi,

}

impl xgHOWu {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<xgHOWu> {
        Some(xgHOWu {
            nested_types: GgnENC::new(py).unwrap(),
            primitives: XKTQmi::new(py).unwrap(),

        })
    }
}

/// Binds for Python module `call_from_subfirst`
pub struct zMgeQk {
    module: PyModule
}

impl zMgeQk {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<zMgeQk> {
        let module = py.import("test_package.firstdir.subfirstdir.call_from_subfirst");
        match module {
            Ok(m) => Some(
                zMgeQk {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn subfirst_module(&self, py: Python,

    )  {

        let func = self.module.get(py, "subfirst_module").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let aTpdBH = result.extract::<PyObject>(py).unwrap();

        return 

    }

}

/// Struct for folder `subfirstdir`
pub struct pKojCn {
    pub call_from_subfirst: zMgeQk,

}

impl pKojCn {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<pKojCn> {
        Some(pKojCn {
            call_from_subfirst: zMgeQk::new(py).unwrap(),

        })
    }
}

/// Binds for Python module `call_from_first`
pub struct YqSLhZ {
    module: PyModule
}

impl YqSLhZ {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<YqSLhZ> {
        let module = py.import("test_package.firstdir.call_from_first");
        match module {
            Ok(m) => Some(
                YqSLhZ {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn first_module(&self, py: Python,

    )  {

        let func = self.module.get(py, "first_module").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let OfljVO = result.extract::<PyObject>(py).unwrap();

        return 

    }

}

/// Struct for folder `firstdir`
pub struct UnBoVx {
    pub subfirstdir: pKojCn,
    pub call_from_first: YqSLhZ,

}

impl UnBoVx {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<UnBoVx> {
        Some(UnBoVx {
            subfirstdir: pKojCn::new(py).unwrap(),
            call_from_first: YqSLhZ::new(py).unwrap(),

        })
    }
}

/// Binds for Python module `root_module_2`
pub struct YiYUty {
    module: PyModule
}

impl YiYUty {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<YiYUty> {
        let module = py.import("test_package.root_module_2");
        match module {
            Ok(m) => Some(
                YiYUty {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn root_module_2(&self, py: Python,

    )  {

        let func = self.module.get(py, "root_module_2").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let SMPywN = result.extract::<PyObject>(py).unwrap();

        return 

    }

}

/// Binds for Python module `root_module_1`
pub struct EfVgsp {
    module: PyModule
}

impl EfVgsp {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<EfVgsp> {
        let module = py.import("test_package.root_module_1");
        match module {
            Ok(m) => Some(
                EfVgsp {
                    module: m,
                }),
            Err(exception) => {
                handle_import_error(exception);
                None
            }
        }
    }

    pub fn root_module_1(&self, py: Python,

    )  {

        let func = self.module.get(py, "root_module_1").unwrap();

        let result = func.call(py, NoArgs, None).unwrap();
        let bgAQiu = result.extract::<PyObject>(py).unwrap();

        return 

    }

}

/// Struct for folder `test_package`
pub struct VgLvuM {
    pub basics: xgHOWu,
    pub firstdir: UnBoVx,
    pub root_module_2: YiYUty,
    pub root_module_1: EfVgsp,

}

impl VgLvuM {
    /// Loads the module instance to the interpreter
    pub fn new(py: Python) -> Option<VgLvuM> {
        Some(VgLvuM {
            basics: xgHOWu::new(py).unwrap(),
            firstdir: UnBoVx::new(py).unwrap(),
            root_module_2: YiYUty::new(py).unwrap(),
            root_module_1: EfVgsp::new(py).unwrap(),

        })
    }
}

/// Python module manager
pub struct PyModules {
    pub basics: xgHOWu,
    pub firstdir: UnBoVx,
    pub root_module_2: YiYUty,
    pub root_module_1: EfVgsp,

}

impl PyModules {
    pub fn new(py: Python) -> PyModules {
        PyModules {
            basics: xgHOWu::new(py).unwrap(),
            firstdir: UnBoVx::new(py).unwrap(),
            root_module_2: YiYUty::new(py).unwrap(),
            root_module_1: EfVgsp::new(py).unwrap(),

        }
    }
}
